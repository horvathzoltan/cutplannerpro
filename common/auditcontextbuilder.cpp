#include "common/auditcontextbuilder.h"
#include "common/logger.h" // zInfo, zWarning
#include <QMap>

/**
 * @brief Csoportkulcs gener√°l√°sa egy audit sorhoz.
 *        A kulcs most: materialId + rootStorageId
 *        Ez biztos√≠tja, hogy az audit sorok g√©pszinten csoportosuljanak.
 *        A hull√≥k mind k√ºl√∂n csoportot kapnak, √≠gy nem √∂r√∂klik a hi√°nyt, nem aggreg√°l√≥dnak.
 */
// QString AuditContextBuilder::makeGroupKey(const StorageAuditRow& r) {
//     if (r.sourceType == AuditSourceType::Leftover)
//         return r.rowId.toString(); // hull√≥k egyediek, ne csoportosuljanak

//     return QString("%1|%2").arg(r.materialId.toString(), r.rootStorageId.toString());
// }
QString AuditContextBuilder::makeGroupKey(const StorageAuditRow& r) {
    if (r.sourceType == AuditSourceType::Leftover)
        return r.rowId.toString(); // hull√≥k ne csoportosuljanak

    return QString("%1|%2").arg(r.materialId.toString(), r.rootStorageId.toString());
}

/**
 * @brief Audit sorok csoportos√≠t√°sa anyag + rootStorage szerint.
 *        Minden sorhoz l√©trej√∂n egy AuditContext, amely tartalmazza a csoportos√≠tott adatokat.
 *
 * A context tartalmazza:
 * - AuditGroupInfo: materialId, groupKey, rowIds
 * - totalExpected: az adott anyagcsoport teljes elv√°rt mennyis√©ge (aggreg√°lt, nem soronk√©nti!)
 * - totalActual: az adott anyagcsoport t√©nyleges mennyis√©ge (√∂sszegzett)
 * - Minden sorhoz visszaadjuk a saj√°t context pointer√©t
 */
QHash<QUuid, std::shared_ptr<AuditContext>>
AuditContextBuilder::buildFromRows(const QList<StorageAuditRow>& rows,
                                   const QMap<QUuid,int>& requiredStockMaterials)
{
    // 1Ô∏è‚É£ Csoportos√≠t√°s kulcsra: materialId + rootStorageId
    //    ‚Üí minden anyag+hely kombin√°ci√≥ egy csoportot alkot
    QHash<QString, QList<const StorageAuditRow*>> groups;
    groups.reserve(rows.size());

    for (const auto& r : rows) {
        groups[makeGroupKey(r)].push_back(&r);

        // Debug log: minden sor beker√ºl a csoportba
        zInfo(L("[AuditContextBuilder] Row collected | rowId=%1 | matId=%2 | storage=%3 | rootStorage=%4 | picking=%5 | actual=%6")
                  .arg(r.rowId.toString())
                  .arg(r.materialId.toString())
                  .arg(r.storageName)
                  .arg(r.rootStorageId.toString())
                  .arg(r.pickingQuantity)
                  .arg(r.actualQuantity));
    }

    // 2Ô∏è‚É£ Kontextus l√©trehoz√°s √©s visszacsatol√°s rowId-hoz
    QHash<QUuid, std::shared_ptr<AuditContext>> result;
    result.reserve(rows.size());

    for (auto it = groups.begin(); it != groups.end(); ++it) {
        const QString& key = it.key();
        const auto& grp = it.value();
        if (grp.isEmpty()) continue;

        auto ctx = std::make_shared<AuditContext>(key, grp.first()->materialId);

        ctx->totalExpected = 0;
        ctx->totalActual   = 0;

        zInfo(L("[AuditContextBuilder] Building context for groupKey=%1 | rows=%2")
                  .arg(key)
                  .arg(grp.size()));

        // 2/A: t√©nyleges mennyis√©g √∂sszegz√©se √©s sorok hozz√°rendel√©se
        for (const auto* r : grp) {
            ctx->totalActual += r->actualQuantity;
            ctx->group.addRow(r->rowId);

            zInfo(L("   adding rowId=%1 | picking=%2 | actual=%3 | runningActual=%4")
                      .arg(r->rowId.toString())
                      .arg(r->pickingQuantity)   // sor szint≈± jelz≈ë, de nem aggreg√°ljuk
                      .arg(r->actualQuantity)
                      .arg(ctx->totalActual));
        }

        // 2/B: elv√°rt mennyis√©g be√°ll√≠t√°sa anyagcsoport szinten a planb≈ël
        ctx->totalExpected = requiredStockMaterials.value(grp.first()->materialId, 0);

        zInfo(L("   >> Context ready: expected=%1 | actual=%2 | rows=%3")
                  .arg(ctx->totalExpected)
                  .arg(ctx->totalActual)
                  .arg(ctx->group.size()));

        // 3Ô∏è‚É£ Minden sorhoz hozz√°rendelj√ºk a k√∂z√∂s context pointert
        for (const auto* r : grp) {
            result.insert(r->rowId, ctx);
        }
    }


    // ‚úÖ √ñsszegz√©s
    zInfo(L("üìä AuditContextBuilder k√©sz: %1 csoport, %2 sor")
              .arg(groups.size())
              .arg(rows.size()));

    return result;
}

// /**
//  * @brief Audit sorok csoportos√≠t√°sa anyag + rootStorage szerint.
//  *        Minden sorhoz l√©trej√∂n egy AuditContext, amely tartalmazza a csoportos√≠tott adatokat.
//  *
//  * A context tartalmazza:
//  * - AuditGroupInfo: materialId, groupKey, rowIds, totalExpected, totalActual
//  * - Minden sorhoz visszaadjuk a saj√°t context pointer√©t
//  */
// QHash<QUuid, std::shared_ptr<AuditContext>>
// AuditContextBuilder::buildFromRows(const QList<StorageAuditRow>& rows)
// {
//     // 1Ô∏è‚É£ Csoportos√≠t√°s kulcsra: materialId + rootStorageId
//     QHash<QString, QList<const StorageAuditRow*>> groups;
//     groups.reserve(rows.size());

//     for (const auto& r : rows) {
//         groups[makeGroupKey(r)].push_back(&r);

//         // üîç Sor logol√°sa: rowId, materialId, storageName, rootStorageId, expected, actual
//         zInfo(L("[AuditContextBuilder] Row collected | rowId=%1 | matId=%2 | storage=%3 | rootStorage=%4 | expected=%5 | actual=%6")
//                   .arg(r.rowId.toString())
//                   .arg(r.materialId.toString())
//                   .arg(r.storageName)
//                   .arg(r.rootStorageId.toString())
//                   .arg(r.pickingQuantity)
//                   .arg(r.actualQuantity));
//     }

//     // 2Ô∏è‚É£ Kontextus l√©trehoz√°s √©s visszacsatol√°s rowId-hoz
//     QHash<QUuid, std::shared_ptr<AuditContext>> result;
//     result.reserve(rows.size());

//     for (auto it = groups.begin(); it != groups.end(); ++it) {
//         const QString& key = it.key();
//         const auto& grp = it.value();
//         if (grp.isEmpty()) continue;

//         // üß© √öj AuditContext l√©trehoz√°sa a csoporthoz
//         //auto ctx = std::make_shared<AuditContext>();
//         auto ctx = std::make_shared<AuditContext>(key, grp.first()->materialId);
//         //ctx->group.groupKey = key;
//         //ctx->group = AuditGroupInfo(key);   // ‚úÖ k√∂telez≈ë groupKey konstruktorban
//         //ctx->materialId = grp.first()->materialId;
//         ctx->totalExpected = 0;
//         ctx->totalActual = 0;

//         // üîç Csoport kezdete
//         zInfo(L("[AuditContextBuilder] Building context for groupKey=%1 | rows=%2")
//                   .arg(key)
//                   .arg(grp.size()));

//         for (const auto* r : grp) {
//             ctx->totalExpected += r->pickingQuantity;
//             ctx->totalActual   += r->actualQuantity;
//             ctx->group.addRow(r->rowId);

//             // üîç Sor hozz√°ad√°sa a contexthez
//             zInfo(L("   adding rowId=%1 | expected=%2 | actual=%3 | totals ‚Üí expected=%4, actual=%5")
//                       .arg(r->rowId.toString())
//                       .arg(r->pickingQuantity)
//                       .arg(r->actualQuantity)
//                       .arg(ctx->totalExpected)
//                       .arg(ctx->totalActual));
//         }

//         // 3Ô∏è‚É£ Minden sorhoz hozz√°rendelj√ºk a context pointert
//         for (const auto* r : grp) {
//             result.insert(r->rowId, ctx);
//         }
//     }

//     // ‚úÖ √ñsszegz√©s
//     zInfo(L("üìä AuditContextBuilder k√©sz: %1 csoport, %2 sor")
//               .arg(groups.size())
//               .arg(rows.size()));

//     return result;
// }
