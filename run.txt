🧩 Frissített állapottábla (2025.10.21. – esti állapot)
#	Tevékenység	Terv	Kész	Új	Köv	Megjegyzés
01–12	Relocation + UI alapok	✅	🟢 Kész			stabil
13	CuttingStrategy enum + két fn	✅	🟢 Kész			Enum integrálva az optimize()-ba, ini‑mentés + UI connect működik
14	Cutting plan váltás (UI opció)	✅	🟡 Folyamatban	✅	✅	UI elem elhelyezés finomhangolás hiányzik
15	Anyagcsoportosítás (master–detail Σ sor + detail)	✅	🟡 Folyamatban	✅	🚧 Sprint 3	AuditContext → groupPresence / groupAuditResult getterek, sor vs. csoport státusz szétválasztva
16–20	Hullókezelés (azonosító, másolás, manager, normalizálás)	✅	🔴 Hiányzik	✅	🚧 Sprint 6	teljes blokk hiányzik
21	Adatfeltöltés + éles teszt	✅	🔴 Hiányzik	✅	🚧 nincs adatimport	kritikus hiány
25	Vágási utasítás dialógus + validáció	✅	🟡 Folyamatban	✅	✅	validáció részben kész (gépválasztás, kerf)
26	Finalize gomb (UI)	✅	🟡 Részben kész	✅	⚠️	globális finalize hiányzik, cutting lezárása után folytatjuk
28	Finalize auditálás + visszavonás	✅	🔴 Hiányzik		🚧 Sprint 5	teljesen hiányzik
29	Worklist tab (darab szint, finomhangolás)	✅	🟡 Folyamatban	✅	🚧 Sprint 3	operátor UI, darab státusz
30	Leftover sorok kezelése	✅	🟡 Folyamatban	✅	✅	külön sor, leftoverId – részben kész
33	Munkalap–időmanager program	✅	🔴 Hiányzik	✅	🚧 backlog	backlogban
34–41	CutPlan → gép hozzárendelés, kerf gépfüggő, registry validáció, zEvent, UI eseménylista, init összefoglaló, CutPlan státuszvezérelt kezelés	✅	🟡 Folyamatban	✅	🚧 Sprint 4	részben kész, státuszvezérlés hiányzik
🚀 Sprint fókusz (2025.10.21.)
Sprint	Tartalom	Állapot
Sprint 1	plannedQuantity, executedQuantity, finalize logika	🟢 Kész
Sprint 2	UI finomhangolás, CuttingStrategy, Cutting plan váltás	🟢 Kész
Sprint 3	Vágási utasítás dialógus + validáció, Anyagcsoportosítás master–detail, Worklist tab finomhangolás	🟡 Folyamatban
Sprint 4	Finalize UI + soronkénti működés, CutPlan → gép hozzárendelés, kerf gépfüggő, registry validáció, zEvent logger, UI eseménylista, CutPlan státuszvezérelt kezelés	🟡 Folyamatban
Sprint 5	Finalize auditálás + visszavonás, Audit trail export / diff előkészítés	🚧 Előkészítve
Sprint 6	Hullókezelés (azonosító, normalizálás, leftoverId), adatfeltöltés, audit trail export	🚧 Előkészítve
📌 Mai eredmények (2025.10.21.)
🔹 AuditContext
auditStatus() → új tagfüggvény, kiváltja a korábbi AuditStatus::fromGroup() hívásokat.

groupPresence() és groupAuditResult() → tiszta getterek, mindig naprakészek.

confirmedCount → kívülről vezetve, nincs többé körhivatkozás.

🔹 StorageAuditRow
statusType() → refaktor: fromRow() eltávolítva, helyette status() és context->auditStatus() hívások.

statusText() → optimalizálva: suffix kiválasztás külön helperből (suffixForRow()), státusz kiszámítása egy helyen (statusType()).

rowAuditResult mező eltávolítva → felesleges, minden kiszámolható getterekből.

rowPresence → refaktor terv: számított getter (presence()), plusz isFulfilled() kényelmi getter.

🔹 AuditStatus
fromGroup() → áthelyezve az AuditContext osztályba (auditStatus()).

toGroupText() → elavult, helyette context->statusDecorated() javasolt.

statusEmoji() → külön helper, minden dekorált szöveg ebből épül.

🔹 UI logika
Checkbox csak akkor jelenik meg, ha van értelme (eredeti mennyiség, nem módosult).

Mennyiség változtatás → státuszt módosít, de nem automatikusan pipál.

Ha visszaáll az eredeti mennyiség → checkbox újra megjelenik, üresen.

Signal blokkolás csak akkor kell, ha programból true‑ra állítjuk a pipát.

🆕 Felmerült új igények / refaktor ötletek
isAudited() getter: return isRowModified || isRowAuditChecked; → tisztán megmondja, hogy auditáltuk‑e a sort.

presence() + isFulfilled() → számított érték, nem tárolt.

Állapotmátrix szükségessége: isRowModified × isRowAuditChecked × actualQuantity vs. pickingQuantity → ebből egyértelműen kijön statusType() és statusText().

👉 Holnap (2025.10.22.)
Audit logika teljes konzisztenciája: mennyiségváltozás + státusz + checkbox összekapcsolása.

Állapotmátrix megtervezése: minden kombinációra egyértelmű AuditStatus, szöveg és emoji.

Előkészítés a hullókezeléshez: leftoverId, manager, normalizálás.
