2.a. Stockb√≥l j√∂v≈ë rudak stabil azonos√≠t√≥ja

A logban l√°tszik: üÜï Assigned MAT barcode=MAT-204 for stock materialId=... ‚Üí teh√°t a stock rudak m√°r kapnak MAT‚Äëxxxx k√≥dot.

Ez rendben van, de a RodId √©s a MAT barcode m√©g keveredik a badge‚Äëben. A c√©l az, hogy a RodId mindig k√ºl√∂n mez≈ë legyen, a MAT‚Äëxxxx pedig a barcode mez≈ëben. Ez r√©szben k√©sz, de a RodId form√°tum m√©g sz√°mos (Rod-001), nem bet≈±s.

3. Stop felt√©telek visszaemel√©se

A mostani optimize() rod‚Äëloopban m√©g mindig a ‚Äûminden esetben pr√≥b√°ljunk m√©g egy darabot‚Äù logika van.

A h√°rom tartom√°nyos stop‚Äëfelt√©tel (selejt/j√≥/k√∂ztes/t√∫l nagy leftover) m√©g nincs visszahozva.

Teh√°t ez TODO.

5. RodId √©s planCounter sz√©tv√°laszt√°sa

A k√≥dban m√©g mindig rod.rodId = IdentifierUtils::makeRodId(++planCounter); van.

Teh√°t a RodId gener√°l√°s a planCounter‚Äëhez k√∂t√∂tt, nincs k√ºl√∂n rodCounter.

Ez m√©g nincs sz√©tv√°lasztva ‚Üí TODO.

6. Scoring finomhangol√°s

A OptimizerUtils::calcScore() logik√°j√°t nem l√°ttuk, de a logban m√©g mindig el≈ëfordulnak nagy leftoverek (pl. 3348 mm).

Ez arra utal, hogy a kellemetlen leftover b√ºntet√©s m√©g nincs vissza√°ll√≠tva ‚àí300‚Äëra vagy dinamikus sk√°l√°ra.

Ez m√©g nincs megcsin√°lva ‚Üí TODO.
